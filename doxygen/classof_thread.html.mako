<%inherit file="base.mako" />
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    ${self.head()}
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.3.1"/>
    <title>openFrameworks: Class Index</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript">
      $(document).ready(function() { searchBox.OnSelectItem(0); });
    </script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <div id="content">
      ${self.header()}
      <div id="body-wrap">
      		<div class="page-wide">
	            <div class="page-left-split">
           		    <h1 class="documentation">reference</h1> <ul class="docsadvanced"><li><a href="/documentation">basic</a></li> <li><a  class="active" href="/doxygen/annotated.html">advanced</a></li> </ul>
           		</div>
		        <div class="page-right-narrow">
			        <p>This documentation is automatically generated from the openFrameworks source code using doxygen and refers to the most recent release, version <strong>${bf.config.currentVersion}</strong>.</p>
		        </div>
       		</div>
      		<div class="page-wide">
      		    <div class="doxy-mainmenu">
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classof_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ofThread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A threaded base class with a built in mutex for convenience.  
 <a href="classof_thread.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="of_thread_8h_source.html">ofThread.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ofThread:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classof_thread.png" usemap="#ofThread_map" alt=""/>
  <map id="ofThread_map" name="ofThread_map">
<area href="classof_app_e_g_l_window.html" alt="ofAppEGLWindow" shape="rect" coords="0,112,114,136"/>
<area href="classof_u_r_l_file_loader.html" alt="ofURLFileLoader" shape="rect" coords="124,112,238,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a73e55750cdbed68d45a0ba9e7d391c4a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classof_thread.html#a73e55750cdbed68d45a0ba9e7d391c4aacd7c0f12a26a642772db642e8862e98e">INFINITE_JOIN_TIMEOUT</a> = LONG_MAX
 }</td></tr>
<tr class="separator:a73e55750cdbed68d45a0ba9e7d391c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e9afd83f8dd763f7230d13286611a9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a6e9afd83f8dd763f7230d13286611a9c">ofThread</a> ()</td></tr>
<tr class="memdesc:a6e9afd83f8dd763f7230d13286611a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a>.  <a href="#a6e9afd83f8dd763f7230d13286611a9c">More...</a><br/></td></tr>
<tr class="separator:a6e9afd83f8dd763f7230d13286611a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faffc9621a184465b9fdfef0b36b2fd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a8faffc9621a184465b9fdfef0b36b2fd">~ofThread</a> ()</td></tr>
<tr class="memdesc:a8faffc9621a184465b9fdfef0b36b2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a>.  <a href="#a8faffc9621a184465b9fdfef0b36b2fd">More...</a><br/></td></tr>
<tr class="separator:a8faffc9621a184465b9fdfef0b36b2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a51505ea9f5407e8c5999368bd54e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a07a51505ea9f5407e8c5999368bd54e2">isThreadRunning</a> () const </td></tr>
<tr class="memdesc:a07a51505ea9f5407e8c5999368bd54e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the running status of the thread.  <a href="#a07a51505ea9f5407e8c5999368bd54e2">More...</a><br/></td></tr>
<tr class="separator:a07a51505ea9f5407e8c5999368bd54e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c3de0a6eafba5ace00150e0ba39e8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a03c3de0a6eafba5ace00150e0ba39e8e">getThreadId</a> () const </td></tr>
<tr class="memdesc:a03c3de0a6eafba5ace00150e0ba39e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique thread id.  <a href="#a03c3de0a6eafba5ace00150e0ba39e8e">More...</a><br/></td></tr>
<tr class="separator:a03c3de0a6eafba5ace00150e0ba39e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f277270d8f1220397ce78b7abdbf46"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#aa9f277270d8f1220397ce78b7abdbf46">getThreadName</a> () const </td></tr>
<tr class="memdesc:aa9f277270d8f1220397ce78b7abdbf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique thread name, in the form of "Thread id#".  <a href="#aa9f277270d8f1220397ce78b7abdbf46">More...</a><br/></td></tr>
<tr class="separator:aa9f277270d8f1220397ce78b7abdbf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46295f96e3730f6449adca48426c967e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a46295f96e3730f6449adca48426c967e">OF_DEPRECATED_MSG</a> (&quot;Use <a class="el" href="classof_thread.html#a372f918694b7b3a2599af4e70aa236aa">startThread</a>(bool blocking = true) instead.&quot;, void <a class="el" href="classof_thread.html#a372f918694b7b3a2599af4e70aa236aa">startThread</a>(bool mutexesBlock, bool verbose))</td></tr>
<tr class="memdesc:a46295f96e3730f6449adca48426c967e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the thread with options.  <a href="#a46295f96e3730f6449adca48426c967e">More...</a><br/></td></tr>
<tr class="separator:a46295f96e3730f6449adca48426c967e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372f918694b7b3a2599af4e70aa236aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a372f918694b7b3a2599af4e70aa236aa">startThread</a> (bool mutexBlocks=true)</td></tr>
<tr class="memdesc:a372f918694b7b3a2599af4e70aa236aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the thread with options.  <a href="#a372f918694b7b3a2599af4e70aa236aa">More...</a><br/></td></tr>
<tr class="separator:a372f918694b7b3a2599af4e70aa236aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b682673b3d11225785b74f68fc3ce96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a8b682673b3d11225785b74f68fc3ce96">lock</a> ()</td></tr>
<tr class="memdesc:a8b682673b3d11225785b74f68fc3ce96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the mutex.  <a href="#a8b682673b3d11225785b74f68fc3ce96">More...</a><br/></td></tr>
<tr class="separator:a8b682673b3d11225785b74f68fc3ce96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fd09fe1a8db65c2444abab0e806831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a98fd09fe1a8db65c2444abab0e806831">unlock</a> ()</td></tr>
<tr class="memdesc:a98fd09fe1a8db65c2444abab0e806831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the mutex.  <a href="#a98fd09fe1a8db65c2444abab0e806831">More...</a><br/></td></tr>
<tr class="separator:a98fd09fe1a8db65c2444abab0e806831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3102a3bf7897f579d70a418ae3ed010b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a3102a3bf7897f579d70a418ae3ed010b">stopThread</a> ()</td></tr>
<tr class="memdesc:a3102a3bf7897f579d70a418ae3ed010b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the thread.  <a href="#a3102a3bf7897f579d70a418ae3ed010b">More...</a><br/></td></tr>
<tr class="separator:a3102a3bf7897f579d70a418ae3ed010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faefa778ff5338ee7add57dd5ec2a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a4faefa778ff5338ee7add57dd5ec2a5f">waitForThread</a> (bool callStopThread=true, long milliseconds=<a class="el" href="classof_thread.html#a73e55750cdbed68d45a0ba9e7d391c4aacd7c0f12a26a642772db642e8862e98e">INFINITE_JOIN_TIMEOUT</a>)</td></tr>
<tr class="memdesc:a4faefa778ff5338ee7add57dd5ec2a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the thread to exit (aka "joining" the thread).  <a href="#a4faefa778ff5338ee7add57dd5ec2a5f">More...</a><br/></td></tr>
<tr class="separator:a4faefa778ff5338ee7add57dd5ec2a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e99dc383aba491a664efad32d2d7ccb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a9e99dc383aba491a664efad32d2d7ccb">sleep</a> (long milliseconds)</td></tr>
<tr class="memdesc:a9e99dc383aba491a664efad32d2d7ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the thread to sleep for a certain amount of milliseconds.  <a href="#a9e99dc383aba491a664efad32d2d7ccb">More...</a><br/></td></tr>
<tr class="separator:a9e99dc383aba491a664efad32d2d7ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bf3cab66dc5dda34b172784b401003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a35bf3cab66dc5dda34b172784b401003">yield</a> ()</td></tr>
<tr class="memdesc:a35bf3cab66dc5dda34b172784b401003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the thread to give up its CPU time other threads.  <a href="#a35bf3cab66dc5dda34b172784b401003">More...</a><br/></td></tr>
<tr class="separator:a35bf3cab66dc5dda34b172784b401003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b7892fb6c0ddda7fe046aaa019da90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a96b7892fb6c0ddda7fe046aaa019da90">isCurrentThread</a> () const </td></tr>
<tr class="memdesc:a96b7892fb6c0ddda7fe046aaa019da90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the current thread is active.  <a href="#a96b7892fb6c0ddda7fe046aaa019da90">More...</a><br/></td></tr>
<tr class="separator:a96b7892fb6c0ddda7fe046aaa019da90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b607a4239526df49fb23738453645ef"><td class="memItemLeft" align="right" valign="top">Poco::Thread &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a3b607a4239526df49fb23738453645ef">getPocoThread</a> ()</td></tr>
<tr class="memdesc:a3b607a4239526df49fb23738453645ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the underlying Poco thread.  <a href="#a3b607a4239526df49fb23738453645ef">More...</a><br/></td></tr>
<tr class="separator:a3b607a4239526df49fb23738453645ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7533f15b34d6518665e4dcb64f5723d3"><td class="memItemLeft" align="right" valign="top">const Poco::Thread &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a7533f15b34d6518665e4dcb64f5723d3">getPocoThread</a> () const </td></tr>
<tr class="memdesc:a7533f15b34d6518665e4dcb64f5723d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the underlying Poco thread.  <a href="#a7533f15b34d6518665e4dcb64f5723d3">More...</a><br/></td></tr>
<tr class="separator:a7533f15b34d6518665e4dcb64f5723d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49beba601eef1f31fe733fd0e5647f2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a49beba601eef1f31fe733fd0e5647f2b">OF_DEPRECATED_MSG</a> (&quot;use <a class="el" href="classof_thread.html#a4060c79bf667e0ad2fbe78e7d12c2905">ofThread::getCurrentPocoThread</a>() == &amp;yourThread.getPocoThread() to compare threads.&quot;, static <a class="el" href="classof_thread.html">ofThread</a> *getCurrentThread())</td></tr>
<tr class="separator:a49beba601eef1f31fe733fd0e5647f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a23f292adedaad5a0991637a1746d9772"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a23f292adedaad5a0991637a1746d9772">isMainThread</a> ()</td></tr>
<tr class="memdesc:a23f292adedaad5a0991637a1746d9772"><td class="mdescLeft">&#160;</td><td class="mdescRight">A query to see if the current thread is the main thread.  <a href="#a23f292adedaad5a0991637a1746d9772">More...</a><br/></td></tr>
<tr class="separator:a23f292adedaad5a0991637a1746d9772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4060c79bf667e0ad2fbe78e7d12c2905"><td class="memItemLeft" align="right" valign="top">static Poco::Thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a4060c79bf667e0ad2fbe78e7d12c2905">getCurrentPocoThread</a> ()</td></tr>
<tr class="memdesc:a4060c79bf667e0ad2fbe78e7d12c2905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current Poco thread.  <a href="#a4060c79bf667e0ad2fbe78e7d12c2905">More...</a><br/></td></tr>
<tr class="separator:a4060c79bf667e0ad2fbe78e7d12c2905"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7e90ddaf0113435c451e6daf600c33f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a7e90ddaf0113435c451e6daf600c33f1">threadedFunction</a> ()</td></tr>
<tr class="memdesc:a7e90ddaf0113435c451e6daf600c33f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread's run function.  <a href="#a7e90ddaf0113435c451e6daf600c33f1">More...</a><br/></td></tr>
<tr class="separator:a7e90ddaf0113435c451e6daf600c33f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2ac54808d526a915319b3ba81edeeea1"><td class="memItemLeft" align="right" valign="top">Poco::Thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a2ac54808d526a915319b3ba81edeeea1">thread</a></td></tr>
<tr class="memdesc:a2ac54808d526a915319b3ba81edeeea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Poco::Thread that runs the Poco::Runnable.  <a href="#a2ac54808d526a915319b3ba81edeeea1">More...</a><br/></td></tr>
<tr class="separator:a2ac54808d526a915319b3ba81edeeea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ff152ef6ad45f82cff7dcd5b4b9742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="of_types_8h.html#a14d0290b2d9067f9b5c30fa5e4e56927">ofMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread.html#a12ff152ef6ad45f82cff7dcd5b4b9742">mutex</a></td></tr>
<tr class="memdesc:a12ff152ef6ad45f82cff7dcd5b4b9742"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal mutex called through <a class="el" href="classof_thread.html#a8b682673b3d11225785b74f68fc3ce96" title="Try to lock the mutex. ">lock()</a> &amp; <a class="el" href="classof_thread.html#a98fd09fe1a8db65c2444abab0e806831" title="Unlock the mutex. ">unlock()</a>.  <a href="#a12ff152ef6ad45f82cff7dcd5b4b9742">More...</a><br/></td></tr>
<tr class="separator:a12ff152ef6ad45f82cff7dcd5b4b9742"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A threaded base class with a built in mutex for convenience. </p>
<p>Users can extend this base class by public inheritance like this: </p>
<pre class="fragment">class MyThreadedClass: public ofThread
{
    public:
    /// ...
    void threadedFunction()
    {
        while(isThreadRunning())
        {
            /// Threaded function here.
        }
    }
};
</pre><p><a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> is a convenient wrapper for Poco::Thread, Poco::Runnable and Poco::Mutex. It represents a simplified (sometimes overly simplified - or simplified in ways that might not make sense for your project) pathway for quickly writing threaded classes. Poco::Runnable represents a class that can be "run" via its void run() method. Poco::Thread is able to spawn a thread and "run" the contents of a class that extends the Poco::Runnable interface (which <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> does). Poco::FastMutex, (aka ofMutex) is a "mutual exclusion" object that prevents two threads from accessing the same data at the same time. It is important to know that Poco::FastMutex (aka ofMutex) is not "recursive" while Poco::Mutex is. This means that if the same thread attempts to lock a thread while it ALREADY has a lock on the mutex, the program will lock up and go nowhere. Thus, it is important that <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> subclasses carefully their use of the mutex. Currently <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> does not lock its own mutex at any point (e.g. <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a>'s internal variables are not thread safe). This is a somewhat dangerous convenience that is (theoretically) supposed to make it easier for subclasses to avoid the recursive mutex "problem". The situation that arises from two threads simultanously reading or writing from the same shared data (shared data occupies the same physical location in memory) leads to something called a "race condition", which can lead to deadlocks. A deadlock is as bad as it sounds. It means your program just stops. ofMutex prevents race conditions, deadlocks and crashes by permitting only one thread access to shared data at a time. When using mutexes to protect data, the trick is to always be sure to unlock the mutex when finished. This problem can often be avoided by using an Poco::FastMutex::ScopedLock (aka ofScopedLock). See the the documentation for more information. Finally, there are many cases where it might make more sense to use Poco::Thread, Poco::Runnable and Poco::FastMutex directly rather than using <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a>. Further, cross platform thread management will be alleviated with the std::thread support library included with C++11. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a73e55750cdbed68d45a0ba9e7d391c4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a73e55750cdbed68d45a0ba9e7d391c4aacd7c0f12a26a642772db642e8862e98e"></a>INFINITE_JOIN_TIMEOUT</em>&nbsp;</td><td class="fielddoc">
<p>An sentinal value for an infinite join timeout. </p>
<p>Primarily used with the <a class="el" href="classof_thread.html#a4faefa778ff5338ee7add57dd5ec2a5f" title="Wait for the thread to exit (aka &quot;joining&quot; the thread). ">waitForThread()</a> method. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6e9afd83f8dd763f7230d13286611a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ofThread::ofThread </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a>. </p>

</div>
</div>
<a class="anchor" id="a8faffc9621a184465b9fdfef0b36b2fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ofThread::~ofThread </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>The destructor WILL NOT stop the thread or wait for the underlying Poco::Thread to finish. For threads that require the correct deallocation of resources, the user MUST call waitForThread(...); to ensure that the thread is stopped and the thread's resources are released. Improper release of resources or memory can lead to segementation faults and other errors. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4060c79bf667e0ad2fbe78e7d12c2905"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Poco::Thread * ofThread::getCurrentPocoThread </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current Poco thread. </p>
<p>In most cases, it is more appropriate to query the current thread by calling <a class="el" href="classof_thread.html#a96b7892fb6c0ddda7fe046aaa019da90" title="Query whether the current thread is active. ">isCurrentThread()</a> on an active thread or by calling <a class="el" href="classof_thread.html#a23f292adedaad5a0991637a1746d9772" title="A query to see if the current thread is the main thread. ">ofThread::isMainThread()</a>. See the method documentation for more information on those methods.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the current active thread OR 0 iff the main application thread is active. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b607a4239526df49fb23738453645ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Poco::Thread &amp; ofThread::getPocoThread </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the underlying Poco thread. </p>
<p>Poco::Thread provides a clean cross-platform wrapper for threads. On occasion, it may be useful to interact with the underlying Poco::Thread directly.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the backing Poco thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a7533f15b34d6518665e4dcb64f5723d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Poco::Thread &amp; ofThread::getPocoThread </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const reference to the underlying Poco thread. </p>
<p>Poco::Thread provides a clean cross-platform wrapper for threads. On occasion, it may be useful to interact with the underlying Poco::Thread directly.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the backing Poco thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a03c3de0a6eafba5ace00150e0ba39e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ofThread::getThreadId </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique thread id. </p>
<dl class="section note"><dt>Note</dt><dd>This is NOT the the same as the operating thread id! </dd></dl>

</div>
</div>
<a class="anchor" id="aa9f277270d8f1220397ce78b7abdbf46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ofThread::getThreadName </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique thread name, in the form of "Thread id#". </p>
<dl class="section return"><dt>Returns</dt><dd>the Thread ID string. </dd></dl>

</div>
</div>
<a class="anchor" id="a96b7892fb6c0ddda7fe046aaa019da90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ofThread::isCurrentThread </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the current thread is active. </p>
<p>In multithreaded situations, it can be useful to know which thread is currently running some code in order to make sure only certain threads can do certain things. For example, OpenGL can only run in the main execution thread. Thus, situations where a thread is responsible for interacting with graphics resources may need to prevent graphics updates unless the main thread is accessing or updating resources shared with this <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> (or its subclass). </p>
<pre class="fragment">if(myThread.isCurrentThread())
{
    // do some myThread things,
    // but keep your hands off my resources!
}
else if(ofThread::isMainThread())
{
    // pheew! ok, update those graphics resources
}
</pre><p>By way of another example, a subclass of <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> may have an update() method that is called from <a class="el" href="classof_base_app.html">ofBaseApp</a> during the execution of the main application thread. In these cases, the <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> subclass might want to ask itself whether it can, for instance, call update() on an ofImage, in order to send copy some ofPixels to an <a class="el" href="classof_texture.html" title="An OpenGL image on the the graphics card. ">ofTexture</a> on the graphics card.</p>
<dl class="section return"><dt>Returns</dt><dd>True iff this <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> the currently active thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a23f292adedaad5a0991637a1746d9772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ofThread::isMainThread </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A query to see if the current thread is the main thread. </p>
<p>Some functions (e.g. OpenGL calls) can only be executed the main thread. This static function will tell the user what thread is currently active at the moment the method is called. </p>
<pre class="fragment">if (ofThread::isMainThread())
{
    ofLogNotice() &lt;&lt; "This is the main thread!";
}
else
{
    ofLogNotice() &lt;&lt; "This is NOT the main thread.";
}
</pre><dl class="section return"><dt>Returns</dt><dd>true iff the current thread is the main thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a07a51505ea9f5407e8c5999368bd54e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ofThread::isThreadRunning </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the running status of the thread. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff the thread is currently running. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b682673b3d11225785b74f68fc3ce96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ofThread::lock </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock the mutex. </p>
<p>If the thread was started startThread(true), then this call will wait until the mutex is available and return true. If the thread was started startThread(false), this call will return true iff the mutex is was successfully acquired.</p>
<dl class="section return"><dt>Returns</dt><dd>true iff the lock was successfully acquired. </dd></dl>

</div>
</div>
<a class="anchor" id="a46295f96e3730f6449adca48426c967e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ofThread::OF_DEPRECATED_MSG </td>
          <td>(</td>
          <td class="paramtype">&quot;Use <a class="el" href="classof_thread.html#a372f918694b7b3a2599af4e70aa236aa">startThread</a>(bool blocking = true) instead.&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void &#160;</td>
          <td class="paramname"><em>startThread</em>bool mutexesBlock, bool verbose&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the thread with options. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutexesBlock</td><td>Set blocking to true if you want the mutex to block when <a class="el" href="classof_thread.html#a8b682673b3d11225785b74f68fc3ce96" title="Try to lock the mutex. ">lock()</a> is called. </td></tr>
    <tr><td class="paramname">verbose</td><td>use verbose logging methods. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49beba601eef1f31fe733fd0e5647f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ofThread::OF_DEPRECATED_MSG </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is dangerous and should no longer be used. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e99dc383aba491a664efad32d2d7ccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ofThread::sleep </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>milliseconds</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the thread to sleep for a certain amount of milliseconds. </p>
<p>This is useful inside the <a class="el" href="classof_thread.html#a7e90ddaf0113435c451e6daf600c33f1" title="The thread&#39;s run function. ">threadedFunction()</a> when a thread is waiting for input to process: </p>
<pre class="fragment">void MyThreadedClass::threadedFunction()
{
    // start
    while(isThreadRunning())
    {
        // bReadyToProcess can be set from outside the threadedFuntion.
        // perhaps by another thread that downloads data, or loads
        // some media, etc.

        if(bReadyToProcess == true)
        {
            // do some time intensive processing
            bReadyToProcess = false;
        }
        else
        {
            // sleep the thread to give up some cpu
            sleep(20);
        }
    }
    // done
}
</pre><p>If the user does not give the thread a chance to sleep, the thread may take 100% of the CPU core while it's looping as it waits for something to do. This may lead to poor application performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to sleep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a372f918694b7b3a2599af4e70aa236aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ofThread::startThread </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mutexBlocks</em> = <code>true</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the thread with options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutexBlocks</td><td>Set blocking to true if you want the mutex to block when <a class="el" href="classof_thread.html#a8b682673b3d11225785b74f68fc3ce96" title="Try to lock the mutex. ">lock()</a> is called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Subclasses can directly access the mutex and employ thier own locking strategy. </dd></dl>

</div>
</div>
<a class="anchor" id="a3102a3bf7897f579d70a418ae3ed010b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ofThread::stopThread </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the thread. </p>
<p>This does immediately stop the thread from processing, but will only set a flag that must be checked from within your <a class="el" href="classof_thread.html#a7e90ddaf0113435c451e6daf600c33f1" title="The thread&#39;s run function. ">threadedFunction()</a> by calling <a class="el" href="classof_thread.html#a07a51505ea9f5407e8c5999368bd54e2" title="Check the running status of the thread. ">isThreadRunning()</a>. If the user wants to both stop the thread AND wait for the thread to finish processing, the user should call waitForThread(true, ...). </p>

</div>
</div>
<a class="anchor" id="a7e90ddaf0113435c451e6daf600c33f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ofThread::threadedFunction </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The thread's run function. </p>
<p>Users must overide this in your their derived class and then implement their threaded activity inside the loop. If the the users's threadedFunction does not have a loop, the contents of the threadedFunction will be executed once and the thread will then exit.</p>
<p>For tasks that must be repeated, the user can use a while loop that will run repeatedly until the thread's threadRunning is set to false via the <a class="el" href="classof_thread.html#a3102a3bf7897f579d70a418ae3ed010b" title="Stop the thread. ">stopThread()</a> method. </p>
<pre class="fragment">void MyThreadedClass::threadedFunction()
{
    // Start the loop and continue until
    // isThreadRunning() returns false.
    while(isThreadRunning())
    {
        // Do activity repeatedly here:

        // int j = 1 + 1;

        // This while loop will run as fast as it possibly
        // can, consuming as much processor speed as it can.
        // To help the processor stay cool, users are
        // encouraged to let the while loop sleep via the
        // sleep() method, or call the yield() method to let
        // other threads have a turn.  See the sleep() and
        // yield() methods for more information.

        // sleep(100);
    }
</pre> 
<p>Reimplemented in <a class="el" href="classof_app_e_g_l_window.html#a3ae549b0d4f26ba0ba3200554dd659d2">ofAppEGLWindow</a>, and <a class="el" href="classof_u_r_l_file_loader.html#ab2f0c21ed1cb176e86761370297d573f">ofURLFileLoader</a>.</p>

</div>
</div>
<a class="anchor" id="a98fd09fe1a8db65c2444abab0e806831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ofThread::unlock </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the mutex. </p>
<p>This will only unlocks the mutex if it was previously by the same calling thread. </p>

</div>
</div>
<a class="anchor" id="a4faefa778ff5338ee7add57dd5ec2a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ofThread::waitForThread </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>callStopThread</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>milliseconds</em> = <code><a class="el" href="classof_thread.html#a73e55750cdbed68d45a0ba9e7d391c4aacd7c0f12a26a642772db642e8862e98e">INFINITE_JOIN_TIMEOUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the thread to exit (aka "joining" the thread). </p>
<p>This method waits for a thread will "block" and wait for the thread (aka "join" the thread) before it returns. This allows the user to be sure that the thread is properly cleaned up. An example of when this might be particularly important is if the <a class="el" href="classof_thread.html#a7e90ddaf0113435c451e6daf600c33f1" title="The thread&#39;s run function. ">threadedFunction()</a> is opening a set of network sockets, or downloading data from the web. Destroying an <a class="el" href="classof_thread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> subclass without releasing those sockets (or other resources), may result in segmentation faults, error signals or other undefined behaviors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callStopThread</td><td>Set stop to true if you want to signal the thread to exit before waiting. This is the equivalent to calling <a class="el" href="classof_thread.html#a3102a3bf7897f579d70a418ae3ed010b" title="Stop the thread. ">stopThread()</a>. If you your threadedFunction uses a while-loop that depends on <a class="el" href="classof_thread.html#a07a51505ea9f5407e8c5999368bd54e2" title="Check the running status of the thread. ">isThreadRunning()</a> and you do not call <a class="el" href="classof_thread.html#a3102a3bf7897f579d70a418ae3ed010b" title="Stop the thread. ">stopThread()</a> or set stop == true, waitForThread will hang indefinitely. Set stop == false ONLY if you have already called <a class="el" href="classof_thread.html#a3102a3bf7897f579d70a418ae3ed010b" title="Stop the thread. ">stopThread()</a> and you simply need to be sure your thread has finished its tasks.</td></tr>
    <tr><td class="paramname">milliseconds</td><td>If millseconds is set to INFINITE_JOIN_TIMEOUT, the waitForThread will wait indefinitely for the thread to complete. If milliseconds is set to a lower number (e.g. 10000 for 10 seconds), waitForThread will wait for 10000 milliseconds and if the thread has not yet stopped it will return and log an error message. Users are encouraged to use the default INFINITE_JOIN_TIMEOUT. If the user is unhappy with the amount of time it takes to join a thread, the user is encouraged to seek more expedient ways of signalling their desire for a thread to complete via other signalling methods such as Poco::Event, Poco::Condition, or Poco::Semaphore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://pocoproject.org/slides/090-NotificationsEvents.pdf">http://pocoproject.org/slides/090-NotificationsEvents.pdf</a> </dd>
<dd>
<a href="http://pocoproject.org/docs/Poco.Condition.html">http://pocoproject.org/docs/Poco.Condition.html</a> </dd>
<dd>
<a href="http://pocoproject.org/docs/Poco.Event.html">http://pocoproject.org/docs/Poco.Event.html</a> </dd>
<dd>
<a href="http://pocoproject.org/docs/Poco.Semaphore.html">http://pocoproject.org/docs/Poco.Semaphore.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a35bf3cab66dc5dda34b172784b401003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ofThread::yield </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the thread to give up its CPU time other threads. </p>
<p>This method is similar to <a class="el" href="classof_thread.html#a9e99dc383aba491a664efad32d2d7ccb" title="Tell the thread to sleep for a certain amount of milliseconds. ">sleep()</a> and can often be used in the same way. The main difference is that 1 millisecond (the minimum sleep time available with <a class="el" href="classof_thread.html#a9e99dc383aba491a664efad32d2d7ccb" title="Tell the thread to sleep for a certain amount of milliseconds. ">sleep()</a>) is a very long time on modern processors and <a class="el" href="classof_thread.html#a35bf3cab66dc5dda34b172784b401003" title="Tell the thread to give up its CPU time other threads. ">yield()</a> simply gives up processing time to the next thread, instead of waiting for number of milliseconds. In some cases, this behavior will be preferred. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a12ff152ef6ad45f82cff7dcd5b4b9742"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="of_types_8h.html#a14d0290b2d9067f9b5c30fa5e4e56927">ofMutex</a> ofThread::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal mutex called through <a class="el" href="classof_thread.html#a8b682673b3d11225785b74f68fc3ce96" title="Try to lock the mutex. ">lock()</a> &amp; <a class="el" href="classof_thread.html#a98fd09fe1a8db65c2444abab0e806831" title="Unlock the mutex. ">unlock()</a>. </p>
<p>This mutext can also be used with ofScopedLock within the threaded function by calling: </p>
<pre class="fragment">ofScopedLock lock(mutex);</pre> 
</div>
</div>
<a class="anchor" id="a2ac54808d526a915319b3ba81edeeea1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Poco::Thread ofThread::thread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Poco::Thread that runs the Poco::Runnable. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/arturo/Desktop/openFrameworks/libs/openFrameworks/utils/<a class="el" href="of_thread_8h_source.html">ofThread.h</a></li>
<li>/home/arturo/Desktop/openFrameworks/libs/openFrameworks/utils/<a class="el" href="of_thread_8cpp.html">ofThread.cpp</a></li>
</ul>
</div><!-- contents -->

            </div>
      </div>
      <div id="footer">
        ${self.footer()}
      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>
<%def name="header()">
  <%include file="header.mako" args="active='documentation'" />
</%def>
